# 1. fonction pour formatter les donn?es de consomation
format_conso <- function(Conso) {
  Conso <- Conso[3:nrow(Conso),c(1,2)]
  Conso <- data.table(
    Time = as_datetime(substr(Conso[,1],1,25), tz = NULL),
    P_10min = as.numeric(Conso[,2])
  )
  Conso[,
        kWh_10min := c(NA, # Decalage par rapport a energisme (puissance de 00h00 doit etre affichee au bout de ces 10 minute, a savoir : 00h10)
                       round(Conso$P_10min[1:length(Conso$P_10min)-1]/6000,2)
        )
  ]
  Conso[,Time_1h := paste0(substr(Time,12,13),":00")]
  Conso[,Time_10min := substr(Time,12,16)]
  Conso[,Time_day := as_date(Time)]
  Conso[,Time_month := as_date(Time) - day(Time) + 1]
  
  return(Conso)
  
}

format_conso_ipmvp <- function(Conso_ipmvp) {
  Conso_ipmvp <- Conso_ipmvp[3:nrow(Conso_ipmvp),c(1,2)]
  Conso_ipmvp <- data.table(
    Time = as_datetime(substr(Conso_ipmvp[,1],1,25), tz = NULL),
    P_10min = as.numeric(Conso_ipmvp[,2])
  )
  Conso_ipmvp[,
              kWh_10min := c(# pas de decalage pour ipmvp ;) pr pas engendrer ees problemes en rajotuante des premires ligndes presentants les mois
                round(Conso_ipmvp$P_10min[1:length(Conso_ipmvp$P_10min)]/6000,2)
              )
  ]
  Conso_ipmvp[,Time_1h := paste0(substr(Time,12,13),":00")]
  Conso_ipmvp[,Time_10min := substr(Time,12,16)]
  Conso_ipmvp[,Time_day := as_date(Time)]
  Conso_ipmvp[,Time_month := as_date(Time) - day(Time) + 1]
  
  return(Conso_ipmvp)
}






# 2. Temporal heatmap function------------------------------------------------

Build_HC_Temporal_heatmap <- function(DT=Conso,Date_debut=as.Date("2021-03-01"),
                                      Date_fin=as.Date("2021-03-10"),Aggregation = "heure"){
  
  if (Aggregation == "heure"){
    tooltip_formater <- JS(paste0(
      "
        // correction of aggregated week dates generated by {lubridate::floor_date}
        // In the generating random Data script
        // I want to have on hovering the exact date of the hovered day
        // Not the floor_date Date.
         
        function () {
            function getPointCategoryName(point, dimension) {
              var series = point.series,
              isY = dimension === 'y',
              axis = series[isY ? 'yAxis' : 'xAxis'];
              return axis.categories[point[isY ? 'y' : 'x']];
            }
              var date = getPointCategoryName(this.point, 'y');
              var day = parseInt(date.substring(8,10));
              var month = parseInt(date.substring(5,7)) - 1; // JS begin from 0
              var year = parseInt(date.substring(0,4));
              var date_utc = Date.UTC(year, month, day);
              var date_normal = new Date(date_utc);
              var formated_date = date_normal.toLocaleDateString();
              numero_day = date_normal.getDay();
              if(numero_day===0){
              var day_name = 'Dimanche';
              }
              if(numero_day===1){
              var day_name = 'Lundi';
              }
              if(numero_day===2){
              var day_name = 'Mardi';
              }
              if(numero_day===3){
              var day_name = 'Mercredi';
              }
              if(numero_day===4){
              var day_name = 'Jeudi';
              }
              if(numero_day===5){
              var day_name = 'Vendredi';
              }
              if(numero_day===6){
              var day_name = 'Samedi';
              }
          return day_name + '<b>' + ' ' + formated_date +'</b>' + ' ' + getPointCategoryName(this.point, 'x')  +
          '</b>' +'<br>'+ 'Conso : ' + '<b>' + this.point.value + '<b>' + ' kWh' ;
    }
               ")
    )
    
    Yaxis_formater <- JS("function () {
                      var date = this.value;
                      var day = parseInt(date.substring(8,10));
                      var month = parseInt(date.substring(5,7)) - 1; // JS begin from 0
                      var year = parseInt(date.substring(0,4));
                      var date_utc = Date.UTC(year, month, day);
                      var date_normal = new Date(date_utc);
                      numero_day = date_normal.getDay();
                      var day = [ 'Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
                      return day[numero_day];
                     }")
    
    DT %>%
      filter(
        Time_day >= Date_debut &
          Time_day <= Date_fin
      ) %>% 
      group_by(Time_1h,Time_day) %>%
      summarize(intensity = sum(kWh_10min, na.rm = T)) %>%
      as.data.table() %>% 
      hchart("heatmap",
             hcaes(x = Time_1h, y = Time_day, value= intensity),
             marginTop = 0,
             marginBottom = 0
      ) %>% 
      hc_yAxis(reversed = T, title = "",
               labels = 
                 list(formatter= Yaxis_formater
                 )) %>% 
      hc_xAxis(title="") %>% 
      hc_exporting(enabled = TRUE, formAttributes = list(target = '_blank'))  %>%
      hc_legend(
        align= 'right',
        layout= 'vertical',
        margin= 0,
        verticalAlign= 'top',
        y= 25,
        symbolHeight= 320
      ) %>% 
      hc_colorAxis(
        min = 0,
        minColor= '#FFFFFF',
        maxColor= "#07AE6B"
      ) %>%
      hc_tooltip(formatter = tooltip_formater,
                 borderWidth = 3.5)
    
  } else{
    
    tooltip_formater <- JS(paste0(
      "
        // correction of aggregated week dates generated by {lubridate::floor_date}
        // In the generating random Data script
        // I want to have on hovering the exact date of the hovered day
        // Not the floor_date Date.
         
        function () {
            function getPointCategoryName(point, dimension) {
              var series = point.series,
              isY = dimension === 'y',
              axis = series[isY ? 'yAxis' : 'xAxis'];
              return axis.categories[point[isY ? 'y' : 'x']];
            }
              var date = getPointCategoryName(this.point, 'y');
              var day = parseInt(date.substring(8,10));
              var month = parseInt(date.substring(5,7)) - 1; // JS begin from 0
              var year = parseInt(date.substring(0,4));
              var date_utc = Date.UTC(year, month, day);
              var date_normal = new Date(date_utc);
              var formated_date = date_normal.toLocaleDateString();
              numero_day = date_normal.getDay();
              if(numero_day===0){
              var day_name = 'Dimanche';
              }
              if(numero_day===1){
              var day_name = 'Lundi';
              }
              if(numero_day===2){
              var day_name = 'Mardi';
              }
              if(numero_day===3){
              var day_name = 'Mercredi';
              }
              if(numero_day===4){
              var day_name = 'Jeudi';
              }
              if(numero_day===5){
              var day_name = 'Vendredi';
              }
              if(numero_day===6){
              var day_name = 'Samedi';
              }
          return day_name + '<b>' + ' ' + formated_date +'</b>' + ' ' + getPointCategoryName(this.point, 'x')  +
          '</b>' +'<br>'+ 'Conso : ' + '<b>' + this.point.value + '<b>'  + ' kWh' ;
    }
               ")
    )
    
    Yaxis_formater <- JS("function () {
                      var date = this.value;
                      var day = parseInt(date.substring(8,10));
                      var month = parseInt(date.substring(5,7)) - 1; // JS begin from 0
                      var year = parseInt(date.substring(0,4));
                      var date_utc = Date.UTC(year, month, day);
                      var date_normal = new Date(date_utc);
                      numero_day = date_normal.getDay();
                      var day = [ 'Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
                      return day[numero_day];
                     }")
    
    DT %>%
      filter(
        Time_day >= Date_debut &
          Time_day <= Date_fin
      ) %>% 
      group_by(Time_10min,Time_day) %>%
      summarize(intensity = sum(kWh_10min)) %>%
      as.data.table() %>% 
      hchart("heatmap",
             hcaes(x = Time_10min, y = Time_day, value= intensity),
             marginTop = 0,
             marginBottom = 0
      ) %>% 
      hc_yAxis(reversed = T, title = "",
               labels = list(formatter= Yaxis_formater
               )) %>%
      hc_xAxis(title="") %>% 
      hc_exporting(enabled = TRUE, formAttributes = list(target = '_blank'))  %>%
      hc_legend(
        align= 'right',
        layout= 'vertical',
        margin= 0,
        verticalAlign= 'top',
        y= 25,
        symbolHeight= 320
      ) %>% 
      hc_colorAxis(
        min = 0,
        minColor= '#FFFFFF',
        maxColor= "#07AE6B"
      )  %>%
      hc_tooltip(formatter = tooltip_formater,
                 borderWidth = 3.5)
    
  }
  
}




IPMVP_plot <- function(DT_X, Conso_ipmvp, date_debut_reference,date_fin_reference,date_debut_suivi,date_fin_suivi,
                       APE_date_1,APE_date_2,APE_date_3,
                       APE_1 ="A",APE_2="B",APE_3="C"){
  DT_X_ref <- DT_X %>% 
    as.data.table() %>% 
    rename(Time_month = Date) %>% 
    mutate(Time_month = dmy(Time_month)) %>% 
    filter(
      Time_month >= date_debut_reference &
        Time_month <= date_fin_reference
    )
  DT_X_ref[,Time_month := as_date(Time_month) - day(Time_month) + 1]
  
  DT_X_suivi <- DT_X %>% 
    as.data.table() %>% 
    rename(Time_month = Date) %>% 
    mutate(Time_month = dmy(Time_month)) %>% 
    filter(
      Time_month >= date_debut_suivi &
        Time_month <= date_fin_suivi
    )
  DT_X_suivi[,Time_month := as_date(Time_month) - day(Time_month) + 1]
  
  
  # Rename columns
  if(ncol(DT_X_ref) == 2){
    # Nom de X1 
    X1_name = colnames(DT_X_ref)[2]
    colnames(DT_X_ref)[2] <- "X1"
    colnames(DT_X_suivi)[2] <- "X1"
    # aggr?ger conso en mois
    DT <- Conso_ipmvp %>%
      filter(
        Time_day >= date_debut_reference &
          Time_day <= date_fin_reference
      ) %>% 
      group_by(Time_month) %>%
      summarize(kWh_10min = sum(kWh_10min, na.rm = T)) %>%
      as.data.table()
    DT[,kWh_10min := kWh_10min/1000]
    # conso reel
    DT_suivi <- Conso_ipmvp %>%
      filter(
        Time_day >= date_debut_suivi &
          Time_day <= date_fin_suivi
      ) %>% 
      group_by(Time_month) %>%
      summarize(kWh_10min = sum(kWh_10min, na.rm = T)) %>%
      as.data.table()
    DT_suivi[,kWh_10min := kWh_10min/1000] 
    # Aggr?ger X1 en mois
    DT_X_ref <- DT_X_ref %>%
      group_by(Time_month) %>%
      summarize(X1 = sum(X1, na.rm = T)) %>%
      as.data.table()
    DT_X_suivi <- DT_X_suivi %>%
      group_by(Time_month) %>%
      summarize(X1 = sum(X1, na.rm = T)) %>%
      as.data.table()
    # Modelisation
    DT_model <- as.data.frame(merge(DT,DT_X_ref,by= "Time_month"))
    attach(DT_model)
    Model <- lm(kWh_10min ~ X1)
    R2 <- round(summary(Model)$r.squared,3)
    R2 <- paste0("R-Squared = " ,as.character(R2))
    newdata1 <- data.frame(X1 = DT_X_suivi$X1)
    detach(DT_model)
    DT_model <- predict(Model, newdata1, interval="confidence")
    # http://www.r-tutor.com/elementary-statistics/simple-linear-regression/confidence-interval-linear-regression
    # couleurs :
    couleurs <- sapply(DT_suivi$kWh_10min/DT_model[,1],
                       function(X){
                         if(X>=1){
                           return("#FF6F6F")
                         }
                         if(X<1 & X>=0.95){
                           return("#FFCD33")
                         }
                         if(X<0.95){
                           return("#3AB961")
                         }
                       })
    return(
      list(
        highchart = 
          highchart() %>%
          hc_add_series(
            xts(DT_suivi$kWh_10min, order.by = DT_suivi$Time_month),
            name = "Réalisé",
            type = "column",
            colorByPoint = T,
            colors = unname(couleurs ) ) %>% 
          hc_add_series(name = "Théorique",
                        xts(round(DT_model[,1],5), order.by = DT_suivi$Time_month),
                        type = "spline",
                        dashStyle = 'ShortDash',
                        color = "black",
                        marker = list(enabled = F)) %>% 
          hc_add_series(data.frame(date = as.Date(DT_suivi$Time_month),source1 = round(DT_model[,2],5)
                                   ,source2 = round(DT_model[,3],5) ),
                        hcaes(x = date, low = source1, high = source2),
                        name = "Delta",
                        type = "areasplinerange",
                        lineWidth = 0,
                        color = "#C6ACD9",
                        marker = list(enabled = F),
                        fillOpacity = 0.61) %>% 
          hc_annotations(
            list(
              dragable = 'zz',
              labels = list(
                point = list( x = as.integer(toUTC(APE_date_1)) * 1000, y = 15, xAxis = 0),
                shape = 'circle',
                style = list(
                  fontSize = "15px",
                  fontWeight = "italic",
                  fontFamily = "Lucida Sans"
                ),
                align = 'center',
                text = APE_1,
                backgroundColor = "#1D60A1",
                borderColor = '#1D60A1'
              )
            ),
            list(
              dragable = 'zz',
              labels = list(
                point = list( x = as.integer(toUTC(APE_date_2)) * 1000, y = 15, xAxis = 0),
                shape = 'circle',
                style = list(
                  fontSize = "15px",
                  fontWeight = "italic",
                  fontFamily = "Lucida Sans"
                ),
                align = 'center',
                text = APE_2,
                backgroundColor = "#1D60A1",
                borderColor = '#1D60A1'
              )
            ),
            list(
              dragable = 'zz',
              labels = list(
                point = list( x = as.integer(toUTC(APE_date_3)) * 1000, y = 15, xAxis = 0),
                shape = 'circle',
                style = list(
                  fontSize = "15px",
                  fontWeight = "italic",
                  fontFamily = "Lucida Sans"
                ),
                align = 'center',
                text = APE_3,
                backgroundColor = "#1D60A1",
                borderColor = '#1D60A1'
              )
            )
          ) %>% 
          hc_xAxis(
            type = "datetime",
            labels = list(format = '{value:%b}'),
            title = list(text= ''),
            plotLines = list(
              list(
                color = "#1D60A1",
                width = 1.45,
                value = as.integer(toUTC(APE_date_1)) * 1000,
                zIndex = 4
              ),
              list(
                color = "#1D60A1",
                width = 1.45,
                value = as.integer(toUTC(APE_date_2)) * 1000,
                zIndex = 4
              ),
              list(
                color = "#1D60A1",
                width = 1.45,
                value = as.integer(toUTC(APE_date_3)) * 1000,
                zIndex = 4
              )
            )
          ) %>% 
          hc_tooltip(shared = T) %>% 
          hc_exporting(enabled = TRUE, formAttributes = list(target = '_blank')) %>% 
          hc_legend(enabled = F) %>% 
          hc_yAxis(title = list(text = "mWh")) %>% 
          hc_plotOptions(
            series = list(
              marker = list(
                states = list(
                  hover = list(
                    enabled = T
                  ))
              )
            )
          ),
        R2 = R2
      )
    )
  }
}
